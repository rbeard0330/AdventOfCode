// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Js_math = require("bs-platform/lib/js/js_math.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_HashMap = require("bs-platform/lib/js/belt_HashMap.js");

function correct_ring(target) {
  var ceil = Js_math.ceil_int(Math.sqrt(target));
  if (ceil % 2 === 0) {
    return ceil + 1 | 0;
  } else {
    return ceil;
  }
}

if (correct_ring(1.0) !== 1) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          13,
          0
        ],
        Error: new Error()
      };
}

if (correct_ring(4.0) !== 3) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          14,
          0
        ],
        Error: new Error()
      };
}

if (correct_ring(10.0) !== 5) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          15,
          0
        ],
        Error: new Error()
      };
}

function ring_number(ring_size) {
  return (ring_size - 1 | 0) / 2 | 0;
}

function ring_coordinates(target) {
  var size = correct_ring(target);
  var corner_offset = ring_number(size);
  var steps = target - Math.imul(size - 2 | 0, size - 2 | 0) | 0;
  var full_sides = Caml_int32.div(steps, size - 1 | 0);
  var additional_steps = Caml_int32.mod_(steps, size - 1 | 0);
  switch (full_sides) {
    case 0 :
        return [
                corner_offset,
                (-corner_offset | 0) + additional_steps | 0
              ];
    case 1 :
        return [
                corner_offset - additional_steps | 0,
                corner_offset
              ];
    case 2 :
        return [
                -corner_offset | 0,
                corner_offset - additional_steps | 0
              ];
    case 3 :
        return [
                (-corner_offset | 0) + additional_steps | 0,
                -corner_offset | 0
              ];
    case 4 :
        return [
                corner_offset,
                -corner_offset | 0
              ];
    default:
      return [
              0,
              0
            ];
  }
}

if (!Caml_obj.caml_equal(ring_coordinates(2), [
        1,
        0
      ])) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          38,
          0
        ],
        Error: new Error()
      };
}

if (!Caml_obj.caml_equal(ring_coordinates(14), [
        1,
        2
      ])) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          39,
          0
        ],
        Error: new Error()
      };
}

if (!Caml_obj.caml_equal(ring_coordinates(17), [
        -2,
        2
      ])) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          40,
          0
        ],
        Error: new Error()
      };
}

if (!Caml_obj.caml_equal(ring_coordinates(23), [
        0,
        -2
      ])) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          41,
          0
        ],
        Error: new Error()
      };
}

if (!Caml_obj.caml_equal(ring_coordinates(25), [
        2,
        -2
      ])) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          42,
          0
        ],
        Error: new Error()
      };
}

function manhattan_distance(param) {
  return Pervasives.abs(param[0]) + Pervasives.abs(param[1]) | 0;
}

function solve_1(target) {
  return manhattan_distance(ring_coordinates(target));
}

if (manhattan_distance(ring_coordinates(12)) !== 3) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          48,
          0
        ],
        Error: new Error()
      };
}

if (manhattan_distance(ring_coordinates(23)) !== 2) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          49,
          0
        ],
        Error: new Error()
      };
}

if (manhattan_distance(ring_coordinates(1024)) !== 31) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "d3.res",
          50,
          0
        ],
        Error: new Error()
      };
}

console.log(manhattan_distance(ring_coordinates(277678)));

function hash(param) {
  return param[0] + param[1] | 0;
}

var eq = Caml_obj.caml_equal;

var PointHash = Belt_Id.MakeHashable({
      hash: hash,
      eq: eq
    });

function cart_prod(arr1, arr2) {
  return arr1.map(function (item1) {
                return arr2.map(function (item2) {
                            return [
                                    item1,
                                    item2
                                  ];
                          });
              }).reduce((function (acc, item) {
                return acc.concat(item);
              }), []);
}

var cells = cart_prod([
      -1,
      0,
      1
    ], [
      -1,
      0,
      1
    ]);

function candidates(param) {
  var y = param[1];
  var x = param[0];
  return cells.filter(function (param) {
                if (param[0] !== 0) {
                  return true;
                } else {
                  return param[1] !== 0;
                }
              }).map(function (param) {
              return [
                      x + param[0] | 0,
                      y + param[1] | 0
                    ];
            });
}

var stored = Belt_HashMap.make(100, PointHash);

Belt_HashMap.set(stored, [
      0,
      0
    ], 1);

function get_stored(pair) {
  return Belt_Option.getWithDefault(Belt_HashMap.get(stored, pair), 0);
}

function first_larger_value(target, _current) {
  while(true) {
    var current = _current;
    var coords = ring_coordinates(current);
    var next_value = candidates(coords).map(get_stored).reduce((function (x, y) {
            return x + y | 0;
          }), 0);
    if (next_value > target) {
      return next_value;
    }
    Belt_HashMap.set(stored, coords, next_value);
    _current = current + 1 | 0;
    continue ;
  };
}

console.log(first_larger_value(277678, 2));

var input = 277678;

exports.input = input;
exports.correct_ring = correct_ring;
exports.ring_number = ring_number;
exports.ring_coordinates = ring_coordinates;
exports.manhattan_distance = manhattan_distance;
exports.solve_1 = solve_1;
exports.PointHash = PointHash;
exports.cart_prod = cart_prod;
exports.cells = cells;
exports.candidates = candidates;
exports.stored = stored;
exports.get_stored = get_stored;
exports.first_larger_value = first_larger_value;
/*  Not a pure module */
